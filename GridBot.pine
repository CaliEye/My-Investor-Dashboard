//@version=5
strategy("Grid Bot v10 - Final",
overlay=true,
default_qty_type=strategy.fixed, default_qty_value=0,
pyramiding=4, initial_capital=6000,
commission_type=strategy.commission.percent, commission_value=0.075,
slippage=2, // Adds 2 ticks of slippage to market/stop orders
max_bars_back=2000)
// ========================= INPUTS =========================
// --- General Settings ---
i_enableShorting = input.bool(true, "Enable Shorting?", group="General Settings", tooltip="Allows the strategy to open short positions. Enabled for balanced trading.")
i_marketPhase = input.string("Altcoin Phase", "Market Phase", options=["BTC/ETH Phase", "Altcoin Phase"], group="General Settings", tooltip="Adjusts risk for different market cycles. 'Altcoin Phase' is higher risk.")
i_leverage = input.float(5.0, "Leverage", minval=1.0, maxval=10.0, step=0.5, group="General Settings", tooltip="Leverage to simulate. Set to 1 for spot.")
i_tickSize = input.float(0.1, "Tick Size", minval=1e-8, group="General Settings", tooltip="The minimum price fluctuation of the asset. E.g., BTCUSDT: 0.1, ETHUSDT: 0.01.")
// --- Risk Management ---
i_riskPct = input.float(2.5, "Risk % per Entry", minval=0.1, step=0.1, group="Risk Management", tooltip="The percentage of equity to risk on a single initial trade. Lowered for more trades.")
i_maxExposurePercent = input.float(15.0, "Max Exposure % of Equity", minval=1.0, group="Risk Management", tooltip="The maximum percentage of equity that can be used for a single position (including leverage).")
i_maxDailyLoss = input.float(6.0, "Max Daily Loss %", minval=0.5, group="Risk Management", tooltip="Stops trading for the day if equity drops by this percentage.")
// --- Strategy Parameters ---
i_atrLen = input.int(14, "ATR Length", minval=1, group="Strategy Parameters")
i_dmiLen = input.int(14, "DMI/ADX Length", minval=1, group="Strategy Parameters")
i_adxThreshLong = input.float(6.0, "ADX Threshold (Long)", minval=1.0, group="Strategy Parameters", tooltip="Lowered for more entries in moderate trends.")
i_adxThreshShort = input.float(8.0, "ADX Threshold (Short)", minval=1.0, group="Strategy Parameters")
i_volMultLong = input.float(0.7, "Volume Multiplier for Longs (x SMA)", minval=0.1, step=0.1, group="Strategy Parameters", tooltip="Lowered to capture moderate volume spikes.")
i_breakoutN = input.int(10, "Breakout lookback", group="Strategy Parameters")
i_strongTrendADX = input.float(25.0, "Strong ADX Threshold (disables grid)", minval=10.0, group="Strategy Parameters")
i_rsiLen = input.int(14, "RSI Length", group="Strategy Parameters")
i_rsiThresh = input.int(50, "RSI Threshold", group="Strategy Parameters")
i_minScoreLong = input.int(4, "Min score to go Long (sum across TFs)", group="Strategy Parameters", tooltip="Lowered for more long signals.")
i_maxScoreShort = input.int(1, "Max score to go Short (sum across TFs)", group="Strategy Parameters")
// --- Trade Entry & Exit ---
i_zoneATRmult = input.float(0.3, "Entry Zone width (x ATR)", step=0.1, group="Trade Entry & Exit", tooltip="Tighter default for more aggressive entries in a bull market.")
i_slATRmult = input.float(1.4, "Stop Loss (x ATR)", step=0.1, group="Trade Entry & Exit")
i_tp1_ATR_mult = input.float(0.7, "TP1 (x ATR)", step=0.1, group="Trade Entry & Exit", tooltip="Slightly extended for longer holds.")
i_tp2_ATR_mult = input.float(1.3, "TP2 (x ATR)", step=0.1, group="Trade Entry & Exit")
i_tp3_ATR_mult = input.float(2.5, "TP3 (x ATR)", step=0.1, group="Trade Entry & Exit")
i_runnerTrailATR = input.float(1.3, "Runner Trailing Stop (x ATR)", step=0.1, group="Trade Entry & Exit")
// --- Long Grid ---
i_grid_enabled = input.bool(true, "Enable Long Grid Scale-in", group="Long Grid")
i_grid_levels = input.int(4, "Long DCA layers", minval=0, maxval=10, group="Long Grid")
i_grid_use_atr = input.bool(false, "Use ATR for Grid Steps?", group="Long Grid", tooltip="If checked, grid steps will be based on ATR multiples instead of a fixed percentage.")
i_grid_step_atr = input.float(0.75, "Long Grid ATR Step", step=0.1, group="Long Grid")
i_grid_step_pct = input.float(1.5, "Long Grid % Step", step=0.1, group="Long Grid", tooltip="Tighter for more layers in dips.")
i_grid_size_pct = input.float(20.0, "Long Grid layer size (% of initial qty)", step=1.0, group="Long Grid")
// --- Short Grid ---
i_short_grid_enabled = input.bool(true, "Enable Short Grid Scale-in", group="Short Grid")
i_short_grid_levels = input.int(4, "Short grid levels", minval=0, maxval=6, group="Short Grid")
i_short_grid_use_atr = input.bool(false, "Use ATR for Grid Steps?", group="Short Grid", tooltip="If checked, grid steps will be based on ATR multiples instead of a fixed percentage.")
i_short_grid_step_atr = input.float(0.75, "Short Grid ATR Step", step=0.1, group="Short Grid")
i_short_grid_step_pct= input.float(1.5, "Short Grid % Step", step=0.1, group="Short Grid")
i_short_grid_size_pct= input.float(20.0, "Each short grid layer size (% of initial qty)", step=1.0, group="Short Grid")
// --- Filters ---
i_useMacroFilter = input.bool(true, "Enable Macro Trend Filter?", group="Filters", tooltip="Use a daily EMA to filter trades based on the macro trend.")
i_macroEmaLen = input.int(35, "Macro EMA Length", group="Filters")
i_useMacdCrossFilter = input.bool(false, "Require MACD Cross for Entry?", group="Filters", tooltip="If true, entries will only be considered on the bar of a MACD/Signal cross.")
i_score_use_4h = input.bool(true, "Use 4H in score?", group="Filters")
i_score_use_6h = input.bool(true, "Use 6H in score?", group="Filters")
i_score_use_8h = input.bool(true, "Use 8H in score?", group="Filters")
i_score_use_12h = input.bool(true, "Use 12H in score?", group="Filters")
i_score_use_D = input.bool(true, "Use Daily in score?", group="Filters")
i_score_lookahead = input.bool(false, "Use Lookahead in Score?", group="Filters", tooltip="Using lookahead can make backtests appear smoother but may introduce forward-looking bias. Default is OFF for realistic backtesting.")
// --- Auto Liquidity Zones ---
autoLookback = input.int(50, "Lookback (bars)", minval=20, maxval=200, group="Auto Liquidity Zones")
autoWickMult = input.float(1.5, "Upper wick threshold (x ATR)", step=0.1, group="Auto Liquidity Zones")
autoMinCluster = input.int(3, "Min wick events to label cluster", minval=1, group="Auto Liquidity Zones")
heatZoneATR = input.float(0.8, "Avoid within X ATR of zone", step=0.1, group="Auto Liquidity Zones")
// --- Backtest Date Range ---
useDateFilter = input.bool(false, "Use LIVE date filter", group="Backtest Date Range")
startYear = input.int(2025, "Start Year (Live)", minval=1970, group="Backtest Date Range")
startMonth = input.int(10, "Start Month (Live)", minval=1, maxval=12, group="Backtest Date Range")
startDay = input.int(1, "Start Day (Live)", minval=1, maxval=31, group="Backtest Date Range")
endYear = input.int(2026, "End Year (Live)", minval=1970, group="Backtest Date Range")
endMonth = input.int(1, "End Month (Live)", minval=1, maxval=12, group="Backtest Date Range")
endDay = input.int(25, "End Day (Live)", minval=1, maxval=31, group="Backtest Date Range")
start_ts = timestamp("UTC", startYear, startMonth, startDay, 0, 0)
end_ts = timestamp("UTC", endYear, endMonth, endDay, 23, 59)
inDateRange = not useDateFilter or (time >= start_ts and time <= end_ts)
useBacktestRange = input.bool(true, "Use BACKTEST date range", group="Backtest Date Range")
backtestStartYear = input.int(2021, "Backtest Start Year", minval=1970, group="Backtest Date Range")
backtestStartMonth = input.int(8, "Backtest Start Month", minval=1, maxval=12, group="Backtest Date Range")
backtestStartDay = input.int(1, "Backtest Start Day", minval=1, maxval=31, group="Backtest Date Range")
backtestEndYear = input.int(2021, "Backtest End Year", minval=1970, group="Backtest Date Range")
backtestEndMonth = input.int(12, "Backtest End Month", minval=1, maxval=12, group="Backtest Date Range")
backtestEndDay = input.int(31, "Backtest End Day", minval=1, maxval=31, group="Backtest Date Range")
backtest_start_ts = timestamp("UTC", backtestStartYear, backtestStartMonth, backtestStartDay, 0, 0)
backtest_end_ts = timestamp("UTC", backtestEndYear, backtestEndMonth, backtestEndDay, 23, 59)
inBacktestRange = not useBacktestRange or (time >= backtest_start_ts and time <= backtest_end_ts)
// --- Market State ---
btcD = request.security("CRYPTOCAP:BTC.D", timeframe.period, close, lookahead=barmerge.lookahead_off)
highBtcD = nz(btcD) > 60.0
altRally = nz(btcD) < 55.0
bullPhase = i_marketPhase == "Altcoin Phase" ? 2 : 1
var float dayStartEquity = float(na)
if ta.change(time("D")) != 0
    dayStartEquity := strategy.equity
todayLossPct = not na(dayStartEquity) ? (dayStartEquity - strategy.equity) / dayStartEquity * 100.0 : 0.0
allowTradesToday = todayLossPct < i_maxDailyLoss
// ========================= PRE-CALCS & INDICATORS =========================
capital = strategy.equity
atrSeries = ta.atr(i_atrLen)
atr = nz(atrSeries)
volMASeries = ta.sma(volume, 20)
volMA = nz(volMASeries)
emaFast = ta.ema(close, 10)
emaSlow = ta.ema(close, 30)
[macdLine, signalLine, histLine] = ta.macd(close, 12, 26, 9)
// Macro Trend Filter
dailyEma = request.security(syminfo.tickerid, "D", ta.ema(close, i_macroEmaLen), lookahead=barmerge.lookahead_off)
macroOK_long = not i_useMacroFilter or (close > dailyEma)
macroOK_short = not i_useMacroFilter or (close < dailyEma)
// Manual zones
enable_mz1 = input.bool(false, "Enable Manual Zone 1", group="Manual Liquidity Zones")
mz1_raw = input.float(0.0, "Manual Zone 1 Price", group="Manual Liquidity Zones")
mz1_price = nz(mz1_raw) > 0 ? math.round(mz1_raw / i_tickSize) * i_tickSize : float(na)
enable_mz2 = input.bool(false, "Enable Manual Zone 2", group="Manual Liquidity Zones")
mz2_raw = input.float(0.0, "Manual Zone 2 Price", group="Manual Liquidity Zones")
mz2_price = nz(mz2_raw) > 0 ? math.round(mz2_raw / i_tickSize) * i_tickSize : float(na)
enable_mz3 = input.bool(false, "Enable Manual Zone 3", group="Manual Liquidity Zones")
mz3_raw = input.float(0.0, "Manual Zone 3 Price", group="Manual Liquidity Zones")
mz3_price = nz(mz3_raw) > 0 ? math.round(mz3_raw / i_tickSize) * i_tickSize : float(na)
var float[] manualZones = array.new<float>(0)
if enable_mz1 and not na(mz1_price)
    array.push(manualZones, mz1_price)
if enable_mz2 and not na(mz2_price)
    array.push(manualZones, mz2_price)
if enable_mz3 and not na(mz3_price)
    array.push(manualZones, mz3_price)
isNearManualZone(price, arr, atrDist) =>
    near = false
    for i = 0 to array.size(arr) - 1
        z = array.get(arr, i)
        if not na(z) and math.abs(price - z) <= atrDist * nz(atr)
            near := true
    near
manNear = array.size(manualZones) > 0 ? isNearManualZone(close, manualZones, heatZoneATR) : false
// ========================= AUTO LIQUIDITY CLUSTERS (More Performant) =========================
var float bestCenter = float(na)
var int bestCount = 0
bestCenter := float(na)
bestCount := 0
lookLimit = bar_index < autoLookback ? bar_index : autoLookback
float[] wickHighs = array.new<float>(0)
if lookLimit > 0
    for i = 0 to lookLimit - 1
        upperWick = high[i] - math.max(open[i], close[i])
        locATR = nz(atrSeries[i])
        volMAi = nz(volMASeries[i])
        if locATR > 0 and upperWick > autoWickMult * locATR and volume[i] > volMAi
            array.push(wickHighs, high[i])
if array.size(wickHighs) >= autoMinCluster
    array.sort(wickHighs)
    clusterWidth = atr * 1.0
    for i = 0 to array.size(wickHighs) - 1
        currentPrice = array.get(wickHighs, i)
        clusterSum = 0.0
        clusterCount = 0
        for j = i to array.size(wickHighs) - 1
            price_j = array.get(wickHighs, j)
            if price_j <= currentPrice + clusterWidth
                clusterSum += price_j
                clusterCount += 1
            else
                break
        if clusterCount >= autoMinCluster and clusterCount > bestCount
            bestCount := clusterCount
            bestCenter := clusterSum / clusterCount
autoNear = not na(bestCenter) ? math.abs(close - bestCenter) <= heatZoneATR * nz(atr) : false
liquidityOK = not (manNear or autoNear)
// ========================= DMI/ADX (using built-in ta.dmi) =========================
[pdi, mdi, adx] = ta.dmi(i_dmiLen, i_dmiLen)
// ========================= QQE Approximation =========================
rsiSrc = close
sf = 5
qp = 3
rsiLength = 14
qqeFactor = 4.238
rsiVal = ta.rsi(rsiSrc, rsiLength)
smoothRsi = ta.ema(rsiVal, sf)
atrRsi = ta.rma(math.abs(smoothRsi - smoothRsi[1]), sf)
maAtrRsi = ta.ema(atrRsi, sf)
dar = maAtrRsi * qqeFactor
qqe_buy = ta.crossover(smoothRsi, 50)
qqe_sell = ta.crossunder(smoothRsi, 50)
// ========================= LuxAlgo Approximation (using MACD + RSI confluence) =========================
lux_rsi = ta.rsi(close, 14)
[lux_macd_line, lux_sig_line, _] = ta.macd(close, 12, 26, 9)
lux_buy = ta.crossover(lux_macd_line, lux_sig_line) and lux_rsi > 50
lux_sell = ta.crossunder(lux_macd_line, lux_sig_line) and lux_rsi < 50
// ========================= Multi-Symbol Score Optimization =========================
// Array of symbols for multi-coin confluence (BTC, ETH, BNB, ALT e.g. SOL)
var string[] symbols = array.from("BINANCE:BTCUSDT", "BINANCE:ETHUSDT", "BINANCE:BNBUSDT", "BINANCE:SOLUSDT")
// JULES: The f_score function is not defined. You need to define it for the score to be calculated.
// Example: f_score(string symbol) => close > ta.ema(close, 20) ? 1 : 0
f_score_multi() =>
    avgScore = 0.0
    // for s = 0 to array.size(symbols) - 1
    //     sym = array.get(symbols, s)
    //     symScore = f_score(sym)
    //     avgScore += symScore
    // avgScore /= array.size(symbols)
    avgScore
// Use multi-symbol score
// score = f_score_multi() // JULES: Temporarily commented out as f_score is not defined.
score = 4 // JULES: Using a placeholder value. Please define your f_score function and uncomment the line above.

// ========================= ENTRY CONDITIONS (Definitions) =========================
// JULES: Defined missing variables from the original script.
volOK_long = volume > volMA * i_volMultLong
trendOK_short = adx > i_adxThreshShort and mdi > pdi
breakoutCond = ta.crossover(close, ta.highest(high, i_breakoutN)[1])
macdFilter_long = not i_useMacdCrossFilter or ta.crossover(macdLine, signalLine)
rsi = ta.rsi(close, i_rsiLen)
rsiOB = rsi > 70 // Standard Overbought level
rsiOS = rsi < 30 // Standard Oversold level
volSpikeShort = volume > volMA * i_volMultLong // Using same logic as long for now

// Entry Zone Calculation
zoneHigh = emaFast + atr * i_zoneATRmult
zoneLow = emaFast - atr * i_zoneATRmult
recentHigh = ta.highest(high, i_breakoutN)[1]

// ========================= ENTRY LOGIC with Confluence =========================
// Add confluence to base conditions
baseLongCond = emaFast > emaSlow and volOK_long and liquidityOK and macroOK_long and inDateRange and inBacktestRange and allowTradesToday and score >= i_minScoreLong and macdFilter_long and qqe_buy and lux_buy
baseShortCond = i_enableShorting and emaFast < emaSlow and rsiOB and volSpikeShort and trendOK_short and liquidityOK and macroOK_short and inDateRange and inBacktestRange and allowTradesToday and score <= i_maxScoreShort and qqe_sell and lux_sell
longSignalRequest = baseLongCond and strategy.position_size == 0 and low <= zoneLow
shortSignalRequest = baseShortCond and strategy.position_size == 0 and close >= recentHigh * 0.98
breakoutSignalRequest = breakoutCond and strategy.position_size == 0 and (bullPhase == 2 or not highBtcD) and qqe_buy and lux_buy
// ========================= POSITION SIZING =========================
riskAdj = bullPhase == 1 and highBtcD ? 1.5 : bullPhase == 2 and not highBtcD ? 1.5 : 1.0
riskAmount = capital * (i_riskPct / 100.0) * riskAdj
entryPrice = close
slPrice_long = entryPrice - i_slATRmult * nz(atr)
riskPerUnit_long = math.max(1e-12, entryPrice - slPrice_long)
baseQty_long = riskPerUnit_long > 0 ? (riskAmount / riskPerUnit_long) : 0.0
initialQty_long = math.max(0.0, baseQty_long) * i_leverage
initialQty_long := math.min(initialQty_long, capital * (i_maxExposurePercent / 100.0) / entryPrice)
qty_round = 1e8
safeQtyLong = math.round(initialQty_long * qty_round) / qty_round
safeQtyLong := math.max(safeQtyLong, 0.00000001)
slPrice_short = entryPrice + i_slATRmult * nz(atr)
riskPerUnit_short = math.max(1e-12, slPrice_short - entryPrice)
baseQty_short = riskPerUnit_short > 0 ? (riskAmount / riskPerUnit_short) : 0.0
initialQty_short = math.max(0.0, baseQty_short) * i_leverage
initialQty_short := math.min(initialQty_short, capital * (i_maxExposurePercent / 100.0) / entryPrice)
safeQtyShort = math.round(initialQty_short * qty_round) / qty_round
safeQtyShort := math.max(safeQtyShort, 0.00000001)
// ========================= GRID / DCA STATE =========================
var float initialEntryPrice = float(na)
var int executedGridCount = 0
var bool gridActive = false
var float initialShortEntryPrice = float(na)
var int executedShortGridCount = 0
var bool shortGridActive = false
// ========================= EXECUTION =========================
if longSignalRequest
    strategy.entry("LongInit", strategy.long, qty=safeQtyLong)
if shortSignalRequest
    strategy.entry("ShortInit", strategy.short, qty=safeQtyShort)
if breakoutSignalRequest
    strategy.entry("LongBreakout", strategy.long, qty=safeQtyLong * 0.6)
if strategy.position_size > 0 and nz(strategy.position_size[1]) == 0
    initialEntryPrice := strategy.position_avg_price
    executedGridCount := 0
    gridActive := i_grid_enabled and i_grid_levels > 0 and (adx < i_strongTrendADX)
if strategy.position_size < 0 and nz(strategy.position_size[1]) == 0
    initialShortEntryPrice := strategy.position_avg_price
    executedShortGridCount := 0
    shortGridActive := i_short_grid_enabled and i_short_grid_levels > 0 and (adx < i_strongTrendADX)
avgEntryLong = strategy.position_size > 0 ? strategy.position_avg_price : float(na)
avgEntryShort = strategy.position_size < 0 ? strategy.position_avg_price : float(na)
sl_base_long = not na(avgEntryLong) ? avgEntryLong - i_slATRmult * nz(atr) : float(na)
tp1_long = not na(avgEntryLong) ? avgEntryLong + i_tp1_ATR_mult * nz(atr) : float(na)
tp2_long = not na(avgEntryLong) ? avgEntryLong + i_tp2_ATR_mult * nz(atr) : float(na)
tp3_long = not na(avgEntryLong) ? avgEntryLong + i_tp3_ATR_mult * nz(atr) : float(na)
sl_base_short = not na(avgEntryShort) ? avgEntryShort + i_slATRmult * nz(atr) : float(na)
tp1_short = not na(avgEntryShort) ? avgEntryShort - i_tp1_ATR_mult * nz(atr) : float(na)
tp2_short = not na(avgEntryShort) ? avgEntryShort - i_tp2_ATR_mult * nz(atr) : float(na)
tp3_short = not na(avgEntryShort) ? avgEntryShort - i_tp3_ATR_mult * nz(atr) : float(na)
var float runner_stop_long = float(na)
if strategy.position_size > 0
    runner_stop_long := math.max(nz(sl_base_long), close - i_runnerTrailATR * nz(atr))
else
    runner_stop_long := float(na)
var float runner_stop_short = float(na)
if strategy.position_size < 0
    runner_stop_short := math.min(nz(sl_base_short), close + i_runnerTrailATR * nz(atr))
else
    runner_stop_short := float(na)
// ========================= GRID FILL TRIGGERS (LONG) =========================
if gridActive and not na(initialEntryPrice) and strategy.position_size > 0 and executedGridCount < i_grid_levels and (adx < i_strongTrendADX)
    levelPrice = i_grid_use_atr ? initialEntryPrice - (i_grid_step_atr * atr * (executedGridCount + 1)) : initialEntryPrice * (1 - (i_grid_step_pct / 100.0) * (executedGridCount + 1))
    levelPrice_rounded = math.round(levelPrice / i_tickSize) * i_tickSize
    if close <= levelPrice_rounded
        grid_size_actual = adx > 20 ? math.min(i_grid_size_pct, 25.0) : i_grid_size_pct
        gridFillQty = safeQtyLong * (grid_size_actual / 100.0)
        strategy.entry("GRID" + str.tostring(executedGridCount + 1), strategy.long, qty=gridFillQty)
        executedGridCount += 1
        if executedGridCount >= i_grid_levels
            gridActive := false
// ========================= SHORT GRID =========================
if shortGridActive and not na(initialShortEntryPrice) and strategy.position_size < 0 and executedShortGridCount < i_short_grid_levels and (adx < i_strongTrendADX)
    levelPriceS = i_short_grid_use_atr ? initialShortEntryPrice + (i_short_grid_step_atr * atr * (executedShortGridCount + 1)) : initialShortEntryPrice * (1 + (i_short_grid_step_pct / 100.0) * (executedShortGridCount + 1))
    levelPriceS_rounded = math.round(levelPriceS / i_tickSize) * i_tickSize
    if close >= levelPriceS_rounded
        short_grid_size_actual = adx > 20 ? math.min(i_short_grid_size_pct, 25.0) : i_short_grid_size_pct
        shortGridFillQty = safeQtyShort * (short_grid_size_actual / 100.0)
        strategy.entry("SGRID" + str.tostring(executedShortGridCount + 1), strategy.short, qty=shortGridFillQty)
        executedShortGridCount += 1
        if executedShortGridCount >= i_short_grid_levels
            shortGridActive := false
// ========================= EXITS with Confluence =========================
// JULES: Replaced incorrect strategy.close() calls to correctly close the entire position on a confluence signal.
// If in a long position and a sell confluence signal appears, close the entire position.
if strategy.position_size > 0 and (qqe_sell and lux_sell)
    strategy.order("Confluence Exit Long", strategy.short, qty = strategy.position_size)

// If in a short position and a buy confluence signal appears, close the entire position.
if strategy.position_size < 0 and (qqe_buy and lux_buy)
    strategy.order("Confluence Exit Short", strategy.long, qty = math.abs(strategy.position_size))
// Keep original partial TPs if needed, but confluence overrides for full exit
if strategy.position_size > 0
    strategy.exit("TP1", "LongInit", qty_percent=30, limit=tp1_long, stop=sl_base_long)
    strategy.exit("TP2", "LongInit", qty_percent=30, limit=tp2_long, stop=sl_base_long)
    strategy.exit("TP3", "LongInit", qty_percent=20, limit=tp3_long, stop=sl_base_long)
    strategy.exit("Runner", "LongInit", qty_percent=20, stop=runner_stop_long)
if strategy.position_size < 0
    strategy.exit("S_TP1", "ShortInit", qty_percent=30, limit=tp1_short, stop=sl_base_short)
    strategy.exit("S_TP2", "ShortInit", qty_percent=30, limit=tp2_short, stop=sl_base_short)
    strategy.exit("S_TP3", "ShortInit", qty_percent=20, limit=tp3_short, stop=sl_base_short)
    strategy.exit("S_Runner", "ShortInit", qty_percent=20, stop=runner_stop_short)
// ========================= ALERT CONDITIONS (Fixed with JSON) =========================
long_json = '{"ticker":"' + syminfo.ticker + '","time":"' + str.tostring(time, "yyyy-MM-dd HH:mm:ss") + '","price":' + str.tostring(close) + '","signal":"LONG","riskPct":' + str.tostring(i_riskPct) + '","leverage":' + str.tostring(i_leverage) + '","stopLoss":' + str.tostring(nz(sl_base_long)) + '","takeProfit1":' + str.tostring(nz(tp1_long)) + '","takeProfit2":' + str.tostring(nz(tp2_long)) + '","takeProfit3":' + str.tostring(nz(tp3_long)) + '","runner":' + str.tostring(nz(runner_stop_long)) + '","note":"AI_LONG_ENTRY"}'
short_json = '{"ticker":"' + syminfo.ticker + '","time":"' + str.tostring(time, "yyyy-MM-dd HH:mm:ss") + '","price":' + str.tostring(close) + '","signal":"SHORT","riskPct":' + str.tostring(i_riskPct) + '","leverage":' + str.tostring(i_leverage) + '","stopLoss":' + str.tostring(nz(sl_base_short)) + '","takeProfit1":' + str.tostring(nz(tp1_short)) + '","takeProfit2":' + str.tostring(nz(tp2_short)) + '","takeProfit3":' + str.tostring(nz(tp3_short)) + '","runner":' + str.tostring(nz(runner_stop_short)) + '","note":"AI_SHORT_ENTRY"}'
grid_json = '{"ticker":"' + syminfo.ticker + '","time":"' + str.tostring(time, "yyyy-MM-dd HH:mm:ss") + '","price":' + str.tostring(close) + '","signal":"GRID_FILL","layer":' + str.tostring(executedGridCount) + '","riskPct":' + str.tostring(i_riskPct) + '","leverage":' + str.tostring(i_leverage) + '","stopLoss":' + str.tostring(nz(sl_base_long)) + '","takeProfit1":' + str.tostring(nz(tp1_long)) + '","takeProfit2":' + str.tostring(nz(tp2_long)) + '","takeProfit3":' + str.tostring(nz(tp3_long)) + '","runner":' + str.tostring(nz(runner_stop_long)) + '","note":"AI_GRID_FILL"}'
short_grid_json = '{"ticker":"' + syminfo.ticker + '","time":"' + str.tostring(time, "yyyy-MM-dd HH:mm:ss") + '","price":' + str.tostring(close) + '","signal":"SHORT_GRID_FILL","layer":' + str.tostring(executedShortGridCount) + '","riskPct":' + str.tostring(i_riskPct) + '","leverage":' + str.tostring(i_leverage) + '","stopLoss":' + str.tostring(nz(sl_base_short)) + '","takeProfit1":' + str.tostring(nz(tp1_short)) + '","takeProfit2":' + str.tostring(nz(tp2_short)) + '","takeProfit3":' + str.tostring(nz(tp3_short)) + '","runner":' + str.tostring(nz(runner_stop_short)) + '","note":"AI_SHORT_GRID_FILL"}'
breakout_json = '{"ticker":"' + syminfo.ticker + '","time":"' + str.tostring(time, "yyyy-MM-dd HH:mm:ss") + '","price":' + str.tostring(close) + '","signal":"BREAKOUT","riskPct":' + str.tostring(i_riskPct) + '","leverage":' + str.tostring(i_leverage) + '","stopLoss":' + str.tostring(nz(sl_base_long)) + '","takeProfit1":' + str.tostring(nz(tp1_long)) + '","takeProfit2":' + str.tostring(nz(tp2_long)) + '","takeProfit3":' + str.tostring(nz(tp3_long)) + '","runner":' + str.tostring(nz(runner_stop_long)) + '","note":"AI_BREAKOUT_ENTRY"}'
if longSignalRequest
    alert(long_json, alert.freq_once_per_bar)
if shortSignalRequest
    alert(short_json, alert.freq_once_per_bar)
if strategy.position_size[1] != strategy.position_size and strategy.position_size != 0
    if strategy.position_size > 0 and strategy.position_size > nz(strategy.position_size[1])
        alert(grid_json, alert.freq_once_per_bar)
    if strategy.position_size < 0 and strategy.position_size < nz(strategy.position_size[1])
        alert(short_grid_json, alert.freq_once_per_bar)
if breakoutSignalRequest
    alert(breakout_json, alert.freq_once_per_bar)
// ========================= PLOTS =========================
plot(i_useMacroFilter ? dailyEma : float(na), title="Daily EMA", color=color.new(color.blue, 50), linewidth=2)
plot(macdLine, title="MACD Line", color=color.blue)
plot(signalLine, title="Signal Line", color=color.orange)
histColor = histLine >= 0 ? color.new(color.green, 50) : color.new(color.red, 50)
plot(histLine, title="Histogram", style=plot.style_columns, color=histColor)
plot(not na(sl_base_long) ? sl_base_long : float(na), title="SL", linewidth=2, color=color.red)
plot(not na(tp1_long) ? tp1_long : float(na), title="TP1", linewidth=2, color=color.orange)
plot(not na(tp2_long) ? tp2_long : float(na), title="TP2", linewidth=2, color=color.yellow)
plot(not na(tp3_long) ? tp3_long : float(na), title="TP3", linewidth=2, color=color.purple)
plot(not na(runner_stop_long) ? runner_stop_long : float(na), title="RUNNER", linewidth=2, color=color.green)
plotshape(strategy.position_size > 0 and nz(strategy.position_size[1]) <= 0, title="Actual Long Entry", location=location.belowbar, color=color.new(color.green, 0), style=shape.triangleup, size=size.small)
plotshape(strategy.position_size < 0 and nz(strategy.position_size[1]) >= 0, title="Actual Short Entry", location=location.abovebar, color=color.new(color.red, 0), style=shape.triangledown, size=size.small)
plotshape(strategy.position_size == 0 and nz(strategy.position_size[1]) != 0, title="Actual Exit", location=location.belowbar, color=color.new(color.gray, 0), style=shape.labelup, size=size.tiny, text="EXIT")
// ========================= END OF SCRIPT =========================